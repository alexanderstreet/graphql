<?php

interface ReturnType
{
    public function getBaseName(): string;

    public function getFullName(): string;

    public function getWrappedType(): ReturnType;

    public function getBaseType(): Type;

    public function listed(): ReturnType;

    public function nonNull(): ReturnType;

    public function isList(): bool;

    public function isNonNull(): bool;

    public function verify(Node $node): bool;
}

interface Type
{
    const KIND_SCALAR = 'SCALAR';
    const KIND_OBJECT = 'OBJECT';
    const KIND_INTERFACE = 'INTERFACE';
    const KIND_UNION = 'UNION';
    const KIND_ENUM = 'ENUM';
    const KIND_LIST = 'LIST';
    const KIND_NON_NULL = 'NON_NULL';

    public function getKind(): string;

    public function getName(): string;

    public function verify(Node $node): bool;
}

interface Selection
{
    /**
     * @return string
     */
    public function getName(): string;

    /**
     * @return string
     */
    public function getAlias(): string;

    /**
     * @return array
     */
    public function getArgs();

    /**
     * @return Selection[]
     */
    public function getMembers();
}

abstract class AbstractReturnType implements ReturnType
{
    public function listed(): ReturnType
    {
        return new ListReturnType($this);
    }

    public function nonNull(): ReturnType
    {
        return new NonNullReturnType($this);
    }
}

class ReferencedReturnType extends AbstractReturnType
{
    /**
     * @var Schema
     */
    private $schema;

    /**
     * @var string
     */
    private $name;

    public function __construct(Schema $schema, string $name)
    {
        $this->schema = $schema;
        $this->name = $name;
    }

    public function getBaseName(): string
    {
        return $this->name;
    }

    public function getFullName(): string
    {
        return $this->name;
    }

    public function getWrappedType(): ReturnType
    {
        return $this;
    }

    public function getBaseType(): Type
    {
        return $this->schema->type($this->name);
    }

    public function isList(): bool
    {
        return false;
    }

    public function isNonNull(): bool
    {
        return false;
    }

    public function verify(Node $node): bool
    {
        return $this->schema->type($this->name)->verify($node);
    }
}

class ListReturnType extends AbstractReturnType
{
    /**
     * @var ReturnType
     */
    private $type;

    public function __construct(ReturnType $type)
    {
        $this->type = $type;
    }

    public function getBaseName(): string
    {
        return $this->type->getBaseName();
    }

    public function getFullName(): string
    {
        return sprintf('[%s]', $this->type->getFullName());
    }

    public function getWrappedType(): ReturnType
    {
        return $this->type;
    }

    public function getBaseType(): Type
    {
        return $this->type->getBaseType();
    }

    public function isList(): bool
    {
        return true;
    }

    public function isNonNull(): bool
    {
        return false;
    }

    public function verify(Node $node): bool
    {
        return $this->getWrappedType()->verify($node) && is_array($node->getValue());
    }
}

class NonNullReturnType extends AbstractReturnType
{
    /**
     * @var ReturnType
     */
    private $type;

    public function __construct(ReturnType $type)
    {
        $this->type = $type;
    }

    public function getBaseName(): string
    {
        return $this->type->getBaseName();
    }

    public function getFullName(): string
    {
        return sprintf('%s!', $this->type->getFullName());
    }

    public function getWrappedType(): ReturnType
    {
        return $this->type;
    }

    public function getBaseType(): Type
    {
        return $this->type->getBaseType();
    }

    public function isList(): bool
    {
        return false;
    }

    public function isNonNull(): bool
    {
        return true;
    }

    public function verify(Node $node): bool
    {
        return $this->getWrappedType()->verify($node) && !is_null($node->getValue());
    }
}

abstract class AbstractType implements Type
{
    /**
     * @var string
     */
    private $name;

    /**
     * @var string
     */
    private $kind;

    public function __construct(string $kind, string $name)
    {
        $this->name = $name;
        $this->kind = $kind;
    }

    public function getKind(): string
    {
        return $this->kind;
    }

    public function getName(): string
    {
        return $this->name;
    }
}

class ScalarType extends AbstractType
{
    public function __construct($name)
    {
        parent::__construct(self::KIND_SCALAR, $name);
    }

    public function verify(Node $node): bool
    {
        return true;
    }
}

class ObjectType extends AbstractType
{
    /**
     * @var Field[]
     */
    private $fields = [];

    public function __construct($name)
    {
        parent::__construct(self::KIND_OBJECT, $name);
    }

    public function field(string $name): Field
    {
        if (!array_key_exists($name, $this->fields)) {
            $this->fields[$name] = new Field($this, $name);
        }

        return $this->fields[$name];
    }

    public function fields()
    {
        return $this->fields;
    }

    public function verify(Node $node): bool
    {
        return true;
    }
}

class InterfaceType extends AbstractType
{
    public function verify(Node $node): bool
    {
        return true;
    }
}

class UnionType extends AbstractType
{
    public function verify(Node $node): bool
    {
        return true;
    }
}

class EnumType extends AbstractType
{
    public function verify(Node $node): bool
    {
        return true;
    }
}

class Field
{
    /**
     * @var ObjectType
     */
    private $parentType;

    /**
     * @var string
     */
    private $name;

    /**
     * @var ReturnType[]
     */
    private $arguments = [];

    /**
     * @var ReturnType
     */
    private $returnType;

    /**
     * @var callable
     */
    private $resolver;

    public function __construct(ObjectType $parentType, string $name)
    {
        $this->parentType = $parentType;
        $this->name = $name;
    }

    /**
     * @return ObjectType
     */
    public function getParentType()
    {
        return $this->parentType;
    }

    /**
     * @return ReturnType
     */
    public function getReturnType(): ReturnType
    {
        return $this->returnType;
    }

    /**
     * @param ReturnType $returnType
     * @return $this
     */
    public function setReturnType(ReturnType $returnType)
    {
        $this->returnType = $returnType;
        return $this;
    }

    /**
     * @return callable
     */
    public function getResolver(): callable
    {
        return $this->resolver;
    }

    /**
     * @param callable $resolver
     * @return $this
     */
    public function setResolver(callable $resolver)
    {
        $this->resolver = $resolver;
        return $this;
    }

    /**
     * @param string $name
     * @param ReturnType $type
     * @return $this
     */
    public function setArgument(string $name, ReturnType $type)
    {
        $this->arguments[$name] = $type;
        return $this;
    }

    /**
     * @param string $name
     * @return ReturnType
     */
    public function getArgument(string $name): ReturnType
    {
        return $this->arguments[$name];
    }

    /**
     * @return ReturnType[]
     */
    public function getArguments()
    {
        return $this->arguments;
    }
}

class Schema
{
    /**
     * @var Type[]
     */
    private $types = [];

    /**
     * @param $name
     * @return ReturnType
     */
    public function __get($name)
    {
        return $this->returns($name);
    }

    public function returns($name): ReturnType
    {
        return new ReferencedReturnType($this, $name);
    }

    public function type(string $name): Type
    {
        return $this->types[$name];
    }

    public function put(Type... $types)
    {
        foreach ($types as $type) {
            $this->types[$type->getName()] = $type;
        }
        return $this;
    }

    public function select(Selection $query)
    {
    }
}

class SelectionNode implements Selection
{
    /**
     * @var string
     */
    private $name;

    /**
     * @var array
     */
    private $members;

    /**
     * @var array
     */
    private $args;

    /**
     * @var string
     */
    private $alias;

    public function __construct(string $name, $args = [], $members = [], string $alias = null)
    {
        $this->name = $name;
        $this->members = $members;
        $this->args = $args;
        $this->alias = $alias ?? $name;
    }

    /**
     * @return string
     */
    public function getName(): string
    {
        return $this->name;
    }

    /**
     * @return string
     */
    public function getAlias(): string
    {
        return $this->alias;
    }

    /**
     * @return array
     */
    public function getArgs()
    {
        return $this->args;
    }

    /**
     * @return Selection[]
     */
    public function getMembers()
    {
        return $this->members;
    }
}

function buildQuery(Schema $schema)
{
    $type = new ObjectType('Query');
    $schema->put($type);

    $type->field('query')
        ->setReturnType($schema->Query);

    $type->field('entity')
        ->setReturnType($schema->Entity)
        ->setArgument('id', $schema->ID)
        ->setResolver(function (Node $node) {
            return (object) [
            ];
        });

    $type->field('entities')
        ->setReturnType($schema->Entity->nonNull()->listed())
        ->setResolver(function () {
        });

    return $type;
}

function buildEntity(Schema $schema)
{
    $type = new ObjectType('Entity');
    $schema->put($type);

    $type->field('id')
        ->setReturnType($schema->ID->nonNull())
        ->setResolver(function (Node $node) {
            return 6;
        });

    return $type;
}

interface Node
{
    /**
     * @return Node[]
     */
    public function resolve();
}


class FieldNode
{
}

function executeQuery(Schema $schema, ObjectType $query, Selection $selection)
{
    /**
     * @var Selection[] $queue
     */
    $queue = [$selection];

    $nodes = [];

    while (!empty($queue)) {
        $next = array_shift($queue);
        $nodes[] = new FieldNode();
        $members = $next->getMembers();
        if (!empty($members)) {
            array_push($queue, ...$members);
        }
    }
}

call_user_func_array(function (...$args) {
    $schema = new Schema();

    $schema->put(new ScalarType('ID'));
    $schema->put(new ScalarType('String'));
    $schema->put(new ScalarType('Boolean'));
    $schema->put(new ScalarType('Int'));

    $query = buildQuery($schema);
    buildEntity($schema);

    $selection = new SelectionNode(
        'query',
        [],
        [
            new SelectionNode('entity', ['id' => 5])
        ]
    );

    var_dump(executeQuery($schema, $query, $selection));

}, array_slice($argv, 1));
